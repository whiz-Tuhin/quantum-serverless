# -*- coding: utf-8 -*-
"""vqe_rajiv.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VgVnHyVi6993P6kGj_RQG0o6RveYDWou
"""


from qiskit.circuit.library import RealAmplitudes
from qiskit.algorithms.optimizers import COBYLA, SPSA
from qiskit.providers.fake_provider import FakeKolkata
# from qiskit_aer import AerSimulator
from qiskit.result import ProbDistribution
from qiskit.opflow import I, X, Y, Z
from qiskit_ibm_runtime import Options
from qiskit import QuantumCircuit
# from qiskit_aer.noise import NoiseModel
from qiskit import IBMQ
import pickle
import sys

from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Session
# from circuit_knitting_toolbox.circuit_cutting.wire_cutting import cut_circuit_wires, reconstruct_full_distribution, evaluate_subcircuits

import numpy as np
from math import ceil
import time


def save_object(obj, filename):
    with open(filename, 'wb') as outp:
        pickle.dump(obj, outp, pickle.HIGHEST_PROTOCOL)

qAccesKey = '<IBM QUANTUM API TOKEN>'
service = QiskitRuntimeService(channel="ibm_quantum", token=qAccesKey)
# provider = IBMQ.get_provider(hub='ibm-q-education')

# Shots declaration
shots = 2000
options = Options(execution={"shots": shots}, resilience_level=0)
backends = ['ibmq_qasm_simulator', 'ibmq_qasm_simulator']
backend_name = 'ibmq_qasm_simulator' # replace with a 7-qubit real backend name string
backend = service.get_backend(backend_name)
session = Session(service=service, backend=backend_name)


# define the backend object and the noise model
# backend_oslo= provider.get_backend("ibmq_oslo")
# # create the noise model objects and save into a pickle file
# noise_model_oslo = NoiseModel.from_backend(backend_oslo)
# save_object(noise_model_oslo , "noise_model_oslo_shots_8000_with_resilience_0.pkl")

# # create options with the noise profile
# options_noise_r0_backend_1 = Options(
#     simulator={
#         "noise_model": noise_model_oslo,
#         "seed_simulator": 1234,
#         "coupling_map": backend_oslo.configuration().coupling_map,
#         "basis_gates": backend_oslo.configuration().basis_gates
#     },
#     resilience_level=0,
#     execution={"shots": shots}
# )

#with Session(service=service, backend="ibmq_qasm_simulator") as session:
#    sampler = Sampler(session=session)sampler = Sampler(session=session)

sampler = Sampler(session=session, options=options)

# logging variables
intermediate_energy_values = []
job_ids = []
job_result_timings = []
job_submit_timings = []

def get_current_timestamp_ms():
    return time.time()*1000

def get_expval_zz(counts: dict, i:int) -> float:
    '''returns the expval of H = Z_i Z_{i+1}'''
    # first make sure that counts contains probabilities, if not make it
    if sum(counts.values()) != 1:
        shots = sum(counts.values())
        for key in counts.keys():
            counts[key] = counts[key]/shots
    
    expval = 0
    
    for key, val in counts.items():
        parity = 1 if (int(key[i])+int(key[i+1]))%2 == 0 else -1
        expval += parity*val
    
    return expval

def get_expval(counts: dict) -> float:
    '''returns the expval of H = \sum_i Z_i Z_{i+1}'''
    num_qubits = len(list(counts.keys())[0])
    expval = 0
    
    for idx in range(num_qubits-1):
        expval += get_expval_zz(counts,idx)
    
    return expval

def uncut_objective_function(params:list, shots:int=4000):
    ansatz = RealAmplitudes(num_qubits=num_qubits, reps=reps).bind_parameters(params).decompose()
    ansatz.measure_all()
    
    x = params
    # Execute job with sampler primitive
    submitted_start_time = get_current_timestamp_ms()
    job = sampler.run(ansatz)
    submitted_end_time = get_current_timestamp_ms()
    job_submit_timings.append((submitted_start_time, submitted_end_time))
    
    result_start_time = get_current_timestamp_ms()
    est_result = job.result()
    result_end_time = get_current_timestamp_ms()
    job_result_timings.append((result_start_time, result_end_time))

    
    counts = ProbDistribution(est_result.quasi_dists[0]).binary_probabilities(num_bits=num_qubits)
    
    expval = get_expval(counts)
    print(f"CustomLog[INFO]::JobId::{job.job_id()}::SubmittedTimings::{(submitted_start_time, submitted_end_time)}::ResultTimings::{(result_start_time, result_end_time)}::ExpVal::{expval}")
    intermediate_energy_values.append(expval)

    return expval

# def cut_and_evaluate_circuit(circuit, max_cuts=2, max_subcircuits=[2]):
    
#     cuts = cut_circuit_wires(
#         circuit=circuit,
#         method="automatic",
#         max_subcircuit_width=ceil(circuit.depth()/2),
#         max_cuts=max_cuts,
#         num_subcircuits=max_subcircuits,
#         verbose = False
#         )
    
#     subcircuit_instance_probabilities = evaluate_subcircuits(cuts,
#                                                              service=service,
#                                                              backend_names=backends,
#                                                              options=options,
#                                                             )
    
#     reconstructed_probabilities = reconstruct_full_distribution(circuit, subcircuit_instance_probabilities, cuts)
    
#     reconstructed_distribution = {i: prob for i, prob in enumerate(reconstructed_probabilities)}
    
#     # Represent states as bitstrings (instead of ints)
#     reconstructed_dict_bitstring = ProbDistribution(data=reconstructed_distribution).binary_probabilities(num_bits=num_qubits)
    
#     return reconstructed_dict_bitstring

optimizer = COBYLA(maxiter=120)

num_qubits=6
reps=1
num_vars = RealAmplitudes(num_qubits=num_qubits, reps=reps).num_parameters
init_params = np.random.randn(num_vars)

optimizer_start = get_current_timestamp_ms()
mit_uncut = optimizer.minimize(fun=uncut_objective_function, x0=init_params)
optimizer_end = get_current_timestamp_ms()


# mit_cut = optimizer.minimize(fun=uncut_objective_function, x0=init_params)

# print("energy using circuit cutting: ",mit_cut.fun)
# print("Optimized parameters via circuit cutting: ", mit_cut.x)
print("---------")
print("energy without circuit cutting: ",mit_uncut.fun)
print("Optimized parameters without circuit cutting: ", mit_uncut.x)
print(f"total_optimizer_time::{optimizer_end - optimizer_start}")
print(f"job_ids::{job_ids}")
print(f"intermediate_energy_values::{intermediate_energy_values}")
print(f"job_submit_timings::{job_submit_timings}")
print(f"job_result_timings::{job_result_timings}")